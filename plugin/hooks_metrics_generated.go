// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make pluginapi"
// DO NOT EDIT

package plugin

import (
	"io"
	"net/http"
	timePkg "time"

	"github.com/mattermost/mattermost-server/v5/einterfaces"
	"github.com/mattermost/mattermost-server/v5/model"
)

type hooksMetricsWrapper struct {
	pluginID  string
	hooksImpl Hooks
	metrics   einterfaces.MetricsInterface
}

func (hooks *hooksMetricsWrapper) recordTime(startTime timePkg.Time, name string) {
	if hooks.metrics != nil {
		elapsedTime := float64(timePkg.Since(startTime)) / float64(timePkg.Second)
		hooks.metrics.ObservePluginHookDuration(hooks.pluginID, name, elapsedTime)
	}
}

func (hooks *hooksMetricsWrapper) OnActivate() error {
	startTime := timePkg.Now()
	_returnsA := hooks.hooksImpl.OnActivate()
	hooks.recordTime(startTime, "OnActivate")
	return _returnsA
}

func (hooks *hooksMetricsWrapper) Implemented() ([]string, error) {
	startTime := timePkg.Now()
	_returnsA, _returnsB := hooks.hooksImpl.Implemented()
	hooks.recordTime(startTime, "Implemented")
	return _returnsA, _returnsB
}

func (hooks *hooksMetricsWrapper) OnDeactivate() error {
	startTime := timePkg.Now()
	_returnsA := hooks.hooksImpl.OnDeactivate()
	hooks.recordTime(startTime, "OnDeactivate")
	return _returnsA
}

func (hooks *hooksMetricsWrapper) OnConfigurationChange() error {
	startTime := timePkg.Now()
	_returnsA := hooks.hooksImpl.OnConfigurationChange()
	hooks.recordTime(startTime, "OnConfigurationChange")
	return _returnsA
}

func (hooks *hooksMetricsWrapper) ServeHTTP(c *Context, w http.ResponseWriter, r *http.Request) {
	startTime := timePkg.Now()
	hooks.hooksImpl.ServeHTTP(c, w, r)
	hooks.recordTime(startTime, "ServeHTTP")
}

func (hooks *hooksMetricsWrapper) ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	startTime := timePkg.Now()
	_returnsA, _returnsB := hooks.hooksImpl.ExecuteCommand(c, args)
	hooks.recordTime(startTime, "ExecuteCommand")
	return _returnsA, _returnsB
}

func (hooks *hooksMetricsWrapper) UserHasBeenCreated(c *Context, user *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasBeenCreated(c, user)
	hooks.recordTime(startTime, "UserHasBeenCreated")
}

func (hooks *hooksMetricsWrapper) UserWillLogIn(c *Context, user *model.User) string {
	startTime := timePkg.Now()
	_returnsA := hooks.hooksImpl.UserWillLogIn(c, user)
	hooks.recordTime(startTime, "UserWillLogIn")
	return _returnsA
}

func (hooks *hooksMetricsWrapper) UserHasLoggedIn(c *Context, user *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasLoggedIn(c, user)
	hooks.recordTime(startTime, "UserHasLoggedIn")
}

func (hooks *hooksMetricsWrapper) MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string) {
	startTime := timePkg.Now()
	_returnsA, _returnsB := hooks.hooksImpl.MessageWillBePosted(c, post)
	hooks.recordTime(startTime, "MessageWillBePosted")
	return _returnsA, _returnsB
}

func (hooks *hooksMetricsWrapper) MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string) {
	startTime := timePkg.Now()
	_returnsA, _returnsB := hooks.hooksImpl.MessageWillBeUpdated(c, newPost, oldPost)
	hooks.recordTime(startTime, "MessageWillBeUpdated")
	return _returnsA, _returnsB
}

func (hooks *hooksMetricsWrapper) MessageHasBeenPosted(c *Context, post *model.Post) {
	startTime := timePkg.Now()
	hooks.hooksImpl.MessageHasBeenPosted(c, post)
	hooks.recordTime(startTime, "MessageHasBeenPosted")
}

func (hooks *hooksMetricsWrapper) MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post) {
	startTime := timePkg.Now()
	hooks.hooksImpl.MessageHasBeenUpdated(c, newPost, oldPost)
	hooks.recordTime(startTime, "MessageHasBeenUpdated")
}

func (hooks *hooksMetricsWrapper) ChannelHasBeenCreated(c *Context, channel *model.Channel) {
	startTime := timePkg.Now()
	hooks.hooksImpl.ChannelHasBeenCreated(c, channel)
	hooks.recordTime(startTime, "ChannelHasBeenCreated")
}

func (hooks *hooksMetricsWrapper) UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasJoinedChannel(c, channelMember, actor)
	hooks.recordTime(startTime, "UserHasJoinedChannel")
}

func (hooks *hooksMetricsWrapper) UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasLeftChannel(c, channelMember, actor)
	hooks.recordTime(startTime, "UserHasLeftChannel")
}

func (hooks *hooksMetricsWrapper) UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasJoinedTeam(c, teamMember, actor)
	hooks.recordTime(startTime, "UserHasJoinedTeam")
}

func (hooks *hooksMetricsWrapper) UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	startTime := timePkg.Now()
	hooks.hooksImpl.UserHasLeftTeam(c, teamMember, actor)
	hooks.recordTime(startTime, "UserHasLeftTeam")
}

func (hooks *hooksMetricsWrapper) FileWillBeUploaded(c *Context, info *model.FileInfo, file io.Reader, output io.Writer) (*model.FileInfo, string) {
	startTime := timePkg.Now()
	_returnsA, _returnsB := hooks.hooksImpl.FileWillBeUploaded(c, info, file, output)
	hooks.recordTime(startTime, "FileWillBeUploaded")
	return _returnsA, _returnsB
}
